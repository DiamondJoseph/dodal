import json
import xml.etree.cElementTree as et
from collections import ChainMap
from typing import Any, Dict, Tuple

from dodal.devices.oav.oav_errors import (
    OAVError_BeamPositionNotFound,
    OAVError_ZoomLevelNotFound,
)
from dodal.log import LOGGER

OAV_CONFIG_FILE_DEFAULTS = {
    "zoom_params_file": "/dls_sw/i03/software/gda_versions/gda_9_27/workspace_git/gda-mx.git/configurations/i03-config/xml/jCameraManZoomLevels.xml",
    "oav_json": "/dls_sw/i03/software/gda_versions/gda_9_27/workspace_git/gda-mx.git/configurations/i03-config/etc/OAVCentring.json",
    "display_config": "/dls_sw/i03/software/gda_versions/var/display.configuration",
}


class OAVParameters:
    zoom_params_file: str
    oav_json: str
    display_config: str
    global_params: dict[str, Any]
    context_dicts: dict[str, dict]
    active_params: ChainMap

    exposure: float
    acquire_period: float
    gain: float
    canny_edge_upper_threshold: float
    canny_edge_lower_threshold: float
    minimum_height: int
    zoom: int
    preprocess: int  # gets blur type, e.g. 8 = gaussianBlur, 9 = medianBlur
    preprocess_K_size: int  # length scale for blur preprocessing
    detection_script_filename: str
    close_ksize: int
    input_plugin: str
    mxsc_input: str
    min_callback_time: float
    direction: int
    max_tip_distance: int

    def __init__(
        self,
        centring_params_json: str,
        camera_zoom_levels_file: str,
        display_configuration_file: str,
        context="loopCentring",
        config_files: Dict[str, str] = OAV_CONFIG_FILE_DEFAULTS,
    ):
        self.centring_params_json = centring_params_json
        self.camera_zoom_levels_file = camera_zoom_levels_file
        self.display_configuration_file = display_configuration_file
        self.context = context

        self.global_params, self.context_dicts = self.load_json(
            self.centring_params_json
        )
        self.active_params = ChainMap(
            {}, self.global_params, self.context_dicts[self.context]
        )
        self.update_self_from_current_context()

        self.zoom_params_file = config_files["zoom_params_file"]
        self.oav_json = config_files["oav_json"]
        self.display_config = config_files["display_config"]

        self.load_microns_per_pixel()
        self._extract_beam_position()

    @staticmethod
    def load_json(filename: str) -> tuple[dict[str, Any], dict[str, dict]]:
        """
        Loads the json from the specified file, and returns a dict with all the
        individual top-level k-v pairs, and one with all the subdicts.
        """
        with open(filename) as f:
            raw_params: dict[str, Any] = json.load(f)
        global_params = {k: raw_params.pop(v) for k, v in list(raw_params.items())}
        context_dicts = raw_params
        return global_params, context_dicts

    def update_context(self, context: str) -> None:
        self.active_params.maps.pop()
        self.active_params = self.active_params.new_child(self.context_dicts[context])

    def update_self_from_current_context(self) -> None:
        def update(name, type, default=None):
            try:
                param = self.active_params.get(name, default)
                assert isinstance(param, type)
                return param
            except AssertionError:
                raise TypeError(
                    f"OAV param {name} from the OAV centring params json file has the "
                    f"wrong type, should be {type}."
                )

        self.exposure = update("exposure", float)
        self.acquire_period = update("acqPeriod", float)
        self.gain = update("gain", float)
        self.canny_edge_upper_threshold = update("CannyEdgeUpperThreshold", float)
        self.canny_edge_lower_threshold = update(
            "CannyEdgeLowerThreshold", float, default=5.0
        )
        self.minimum_height = update("minheight", int)
        self.zoom = update("zoom", int)
        self.preprocess = update("preprocess", int)
        self.preprocess_K_size = update("preProcessKSize", int)
        self.detection_script_filename = update("filename", str)
        self.close_ksize = update("close_ksize", int, default=11)

        self.input_plugin = update("oav", str, default="OAV")
        self.mxsc_input = update("mxsc_input", str, default="CAM")
        self.min_callback_time = update("min_callback_time", float, default=0.08)
        self.direction = update("direction", int)
        self.max_tip_distance = update("max_tip_distance", int)

    def load_microns_per_pixel(self, zoom=None):
        """
        Loads the microns per x pixel and y pixel for a given zoom level. These are currently generated by GDA, though artemis could generate them
        in future.
        """
        if not zoom:
            zoom = self.zoom

        tree = et.parse(self.camera_zoom_levels_file)
        self.micronsPerXPixel = self.micronsPerYPixel = None
        root = tree.getroot()
        levels = root.findall(".//zoomLevel")
        for node in levels:
            if float(node.find("level").text) == zoom:
                self.micronsPerXPixel = float(node.find("micronsPerXPixel").text)
                self.micronsPerYPixel = float(node.find("micronsPerYPixel").text)
        if self.micronsPerXPixel is None or self.micronsPerYPixel is None:
            raise OAVError_ZoomLevelNotFound(
                f"Could not find the micronsPer[X,Y]Pixel parameters in {self.camera_zoom_levels_file} for zoom level {zoom}."
            )

        # get the max tip distance in pixels
        self.max_tip_distance_pixels = self.max_tip_distance / self.micronsPerXPixel

    def _extract_beam_position(self):
        """
        Extracts the beam location in pixels `xCentre` `yCentre`. The beam location is
        stored in the file display.configuration. The beam location is manually inputted
        by the beamline operator GDA by clicking where on screen a scintillator ligths up.
        """
        with open(self.display_configuration_file, "r") as f:
            file_lines = f.readlines()
            for i in range(len(file_lines)):
                if file_lines[i].startswith("zoomLevel = " + str(self.zoom)):
                    crosshair_x_line = file_lines[i + 1]
                    crosshair_y_line = file_lines[i + 2]
                    break

            if crosshair_x_line is None or crosshair_y_line is None:
                raise OAVError_BeamPositionNotFound(
                    f"Could not extract beam position at zoom level {self.zoom}"
                )

            self.beam_centre_i = int(crosshair_x_line.split(" = ")[1])
            self.beam_centre_j = int(crosshair_y_line.split(" = ")[1])

            self.beam_centre_x = int(crosshair_x_line.split(" = ")[1])
            self.beam_centre_y = int(crosshair_y_line.split(" = ")[1])
            LOGGER.info(f"Beam centre: {self.beam_centre_i, self.beam_centre_j}")

    def calculate_beam_distance(
        self, horizontal_pixels: int, vertical_pixels: int
    ) -> Tuple[int, int]:
        """
        Calculates the distance between the beam centre and the given (horizontal, vertical).

        Args:
            horizontal_pixels (int): The x (camera coordinates) value in pixels.
            vertical_pixels (int): The y (camera coordinates) value in pixels.
        Returns:
            The distance between the beam centre and the (horizontal, vertical) point in pixels as a tuple
            (horizontal_distance, vertical_distance).
        """

        return (
            self.beam_centre_i - horizontal_pixels,
            self.beam_centre_j - vertical_pixels,
        )
